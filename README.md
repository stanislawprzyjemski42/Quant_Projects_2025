Quantitative Systems & Computational Logic (2025)
# Project Overview
This repository documents a collection of quantitative projects developed between May and December 2025. The work is structured into two distinct categories: Python for building comprehensive analysis systems and C++ for recreational explorations of lower-level algorithmic logic.

To bridge the gap between financial theory and code, I researched various technical tutorials and documentation, adapting those concepts into original, functional implementations. My focus was on the engineering task: ensuring formulas were implemented safely, accurately, and with a clear, modular structure.

üõ† Technical Approach
Python (System Layer): My primary language for building end-to-end analysis tools, data pipelines, and full quantitative systems.

C++ (Logic Layer): Used for recreational deep-dives into computational foundations, practicing memory management and object-oriented design.

Research-Driven: I leveraged industry-standard tutorials to learn best practices for mathematical implementation, then focused on making the code robust and user-ready.

üöÄ Key Implementations
1. Quantitative Analysis Systems (Python)
Files: basic_quant_system.py, improved_quant.py

Focus: Developing modular frameworks for data processing and statistical modeling.

Design: Prioritized "Separation of Concerns" by keeping data ingestion logic independent from core analytical functions.

Outcome: A flexible system capable of handling end-to-end quantitative workflows.

2. Exploratory Pricing Tools (C++)
Files: option_pricing_engine2.cpp, cpp-option-pricer.cpp

Focus: A recreational study of the Black-Scholes model and C++ fundamentals.

CS Fundamentals: Implemented Input Validation to ensure the program handles non-numeric or illogical data (e.g., negative prices) without crashing.

Architecture: Utilized Encapsulation by wrapping pricing logic in classes to improve code maintainability.

üèõ Relevance to Computer Science
While the domain is quantitative finance, the engineering focus is strictly on Computer Science principles:

Tool Specialization: Demonstrating an understanding of when to use high-level languages (Python) for systems versus lower-level languages (C++) for logic.

Defensive Programming: Writing "safe" code that sanitizes user inputs and prevents runtime errors.

Implementation Skills: The ability to take technical documentation or tutorials and translate them into a stable, working software product.

Documentation: Maintaining a clean repository structure and readable code for peer review.

üí° Note on Resources
The mathematical implementations in this repository were made possible through the study of various technical tutorials and open-source documentation. I used these resources to understand the standard approaches to these models, focusing my efforts on the software engineering required to make them robust and implementable.
